<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>计算机网络基本概念 - 啸雨听风</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> 形式语言与自动机</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="FLA-Base.html"><strong aria-hidden="true">1.1.</strong> 形式语言与自动机基础</a></li><li class="chapter-item expanded "><a href="FLA-Regular.html"><strong aria-hidden="true">1.2.</strong> 形式语言与自动机之正则语言</a></li><li class="chapter-item expanded "><a href="FLA-PDA.html"><strong aria-hidden="true">1.3.</strong> 形式语言与自动机之上下文无关语言</a></li><li class="chapter-item expanded "><a href="BNF-EBNF.html"><strong aria-hidden="true">1.4.</strong> BNF和EBNF的含义及其用法</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 算法设计与分析</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Algorithms-Analysis.html"><strong aria-hidden="true">2.1.</strong> 算法之算法分析</a></li><li class="chapter-item expanded "><a href="Algorithms-Greedy.html"><strong aria-hidden="true">2.2.</strong> 算法之贪心法</a></li><li class="chapter-item expanded "><a href="Algorithms-DC.html"><strong aria-hidden="true">2.3.</strong> 算法之分治法</a></li><li class="chapter-item expanded "><a href="Algorithms-DP.html"><strong aria-hidden="true">2.4.</strong> 算法之动态规划</a></li><li class="chapter-item expanded "><a href="Algorithms-Search.html"><strong aria-hidden="true">2.5.</strong> 算法之搜索策略</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 机器学习</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ML-prepare-math.html"><strong aria-hidden="true">3.1.</strong> 机器学习-数学预备知识</a></li><li class="chapter-item expanded "><a href="ML-decision-tree.html"><strong aria-hidden="true">3.2.</strong> 机器学习-决策树</a></li><li class="chapter-item expanded "><a href="ML-LogisticRegression.html"><strong aria-hidden="true">3.3.</strong> 机器学习-逻辑回归</a></li><li class="chapter-item expanded "><a href="ML-LinnerModel.html"><strong aria-hidden="true">3.4.</strong> 机器学习-线性模型</a></li><li class="chapter-item expanded "><a href="ML-GMM-Kmeans.html"><strong aria-hidden="true">3.5.</strong> 机器学习-GMM模型与EM算法</a></li><li class="chapter-item expanded "><a href="ML-PCA.html"><strong aria-hidden="true">3.6.</strong> 机器学习-主成分分析</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 软件构造</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="SC-Base.html"><strong aria-hidden="true">4.1.</strong> 软件构造基础</a></li><li class="chapter-item expanded "><a href="SC-concept.html"><strong aria-hidden="true">4.2.</strong> 软件构造-概念辨析</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 计算机网络</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="about-net.html" class="active"><strong aria-hidden="true">5.1.</strong> 计算机网络基本概念</a></li><li class="chapter-item expanded "><a href="linux-socket.html"><strong aria-hidden="true">5.2.</strong> Linux Socket编程</a></li><li class="chapter-item expanded "><a href="wireshark.html"><strong aria-hidden="true">5.3.</strong> Wireshark解决权限问题</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 编程语言</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> NASM</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="using-nasm.html"><strong aria-hidden="true">6.1.1.</strong> NASM的安装与使用</a></li><li class="chapter-item expanded "><a href="nasm-tutorial.html"><strong aria-hidden="true">6.1.2.</strong> NASM 教程 -- 从HelloWorld说开去</a></li></ol></li><li class="chapter-item expanded "><a href="julia-learn.html"><strong aria-hidden="true">6.2.</strong> JuliaLang 学习</a></li><li class="chapter-item expanded "><a href="boost-python.html"><strong aria-hidden="true">6.3.</strong> Boost::Python 教程</a></li><li class="chapter-item expanded "><a href="latex-circuitikz.html"><strong aria-hidden="true">6.4.</strong> Latex-Circuitikz绘制电路图</a></li><li class="chapter-item expanded "><a href="why-is-INT-MAX-1.html"><strong aria-hidden="true">6.5.</strong> 为什么是-INT_MAX-1</a></li><li class="chapter-item expanded "><a href="pandoc-markdown.html"><strong aria-hidden="true">6.6.</strong> Pandoc's 的 Markdown 语法拓展</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 操作系统</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="win-linux-double-system.html"><strong aria-hidden="true">7.1.</strong> 安装Windows和Linux双系统</a></li><li class="chapter-item expanded "><a href="install-Manjaro.html"><strong aria-hidden="true">7.2.</strong> 配置安装Linux/Manjaro</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 杂项</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Django</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="django-database-separate.html"><strong aria-hidden="true">8.1.1.</strong> Django 多数据库联用</a></li><li class="chapter-item expanded "><a href="django-restfulramework-drf-haystack-whoosh.html"><strong aria-hidden="true">8.1.2.</strong> Django里使用全文搜索框架drf_haystack</a></li></ol></li><li class="chapter-item expanded "><a href="spring-boot-start.html"><strong aria-hidden="true">8.2.</strong> Spring Boot起步</a></li><li class="chapter-item expanded "><a href="compile-lantern.html"><strong aria-hidden="true">8.3.</strong> 编译安装不限流量的Lantern</a></li><li class="chapter-item expanded "><a href="hexo-github.html"><strong aria-hidden="true">8.4.</strong> Travis CI + Hexo部署你的博客</a></li></ol></li><li class="chapter-item expanded "><a href="admin/index.html">CMS</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">啸雨听风</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<hr />
<h2 id="title-计算机网络基本概念"><a class="header" href="#title-计算机网络基本概念">title: 计算机网络基本概念</a></h2>
<h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>了解一下关于计算机网络的基本概念。</p>
<!-- more --> 
<h1 id="基本概念"><a class="header" href="#基本概念">基本概念</a></h1>
<h2 id="ip"><a class="header" href="#ip">IP</a></h2>
<p>互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），缩写为IP地址（英语：IP Address），是分配给网络上使用网际协议（英语：Internet Protocol, IP）的设备的数字标签。常见的IP地址分为IPv4与IPv6两大类。</p>
<h2 id="dns"><a class="header" href="#dns">DNS</a></h2>
<p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p>
<h3 id="域名解析"><a class="header" href="#域名解析">域名解析</a></h3>
<p>举一个例子，zh.wikipedia.org作为一个域名就和IP地址208.80.154.225相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打wikipedia的名字来代替电话号码（IP地址）。DNS在我们直接调用网站的名字以后就会将像zh.wikipedia.org一样便于人类使用的名字转化成像208.80.154.225一样便于机器识别的IP地址。
DNS查询有两种方式：递归和迭代。DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。而DNS服务器之间一般采用迭代查询方式。
以查询zh.wikipedia.org为例：</p>
<ol>
<li>客户端发送查询报文&quot;query zh.wikipedia.org&quot;至DNS服务器，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果。</li>
<li>如果记录老化或不存在，则DNS服务器向根域名服务器发送查询报文&quot;query zh.wikipedia.org&quot;，根域名服务器返回.org域的权威域名服务器地址，这一级首先会返回的是顶级域名的权威域名服务器。</li>
<li>DNS服务器向.org域的权威域名服务器发送查询报文&quot;query zh.wikipedia.org&quot;，得到.wikipedia.org域的权威域名服务器地址。</li>
<li>DNS服务器向.wikipedia.org域的权威域名服务器发送查询报文&quot;query zh.wikipedia.org&quot;，得到主机zh的A记录，存入自身缓存并返回给客户端。</li>
</ol>
<h2 id="子网掩码"><a class="header" href="#子网掩码">子网掩码</a></h2>
<p>子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。</p>
<p>子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p>
<p>子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。</p>
<p>子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位的“与”运算（AND）即得出网络地址来。这样在路由器处理到来的分组时就可以采用同样的方法。</p>
<h2 id="单播多播广播"><a class="header" href="#单播多播广播">单播/多播/广播</a></h2>
<ol>
<li>
<p>单播：网络节点之间的通信就好像是人们之间的对话一样。如果一个人对另外一个人说话，那么用网络技术的术语来描述就是“单播”，此时信息的接收和传递只在两个节点之间进行。单播在网络中得到了广泛的应用，网络上绝大部分的数据都是以单播的形式传输的，只是一般网络用户不知道而已。例如，你在收发电子邮件、浏览网页时，必须与邮件服务器、Web服务器建立连接，此时使用的就是单播数据传输方式。但是通常使用“点对点通信”（Point to Point）代替“单播”，因为“单播”一般与“多播”和“广播”相对应使用。</p>
</li>
<li>
<p>多播：“多播”也可以称为“组播”，在网络技术的应用并不是很多，网上视频会议、网上视频点播特别适合采用多播方式。因为如果采用单播方式，逐个节点传输，有多少个目标节点，就会有多少次传送过程，这种方式显然效率极低，是不可取的；如果采用不区分目标、全部发送的广播方式，虽然一次可以传送完数据，但是显然达不到区分特定数据接收对象的目的。采用多播方式，既可以实现一次传送所有目标节点的数据，也可以达到只对特定对象传送数据的目的。 　　IP网络的多播一般通过多播IP地址来实现。多播IP地址就是D类IP地址，即224.0.0.0至239.255.255.255之间的IP地址。Windows 2000中的DHCP管理器支持多播IP地址的自动分配。 </p>
</li>
<li>
<p>广播：“广播”在网络中的应用较多，如客户机通过DHCP自动获得IP地址的过程就是通过广播来实现的。但是同单播和多播相比，广播几乎占用了子网内网络的所有带宽。拿开会打一个比方吧，在会场上只能有一个人发言，想象一下如果所有的人同时都用麦克风发言，那会场上就会乱成一锅粥。集线器由于其工作原理决定了不可能过滤广播风暴，一般的交换机也没有这一功能，不过现在有的网络交换机（如全向的QS系列交换机）也有过滤广播风暴功能了，路由器本身就有隔离广播风暴的作用。广播风暴不能完全杜绝，但是只能在同一子网内传播，就好像喇叭的声音只能在同一会场内传播一样，因此在由几百台甚至上千台电脑构成的大中型局域网中，一般进行子网划分，就像将一个大厅用墙壁隔离成许多小厅一样，以达到隔离广播风暴的目的。在IP网络中，广播地址用IP地址“255.255.255.255”来表示，这个IP地址代表同一子网内所有的IP地址。</p>
</li>
</ol>
<p>当前的网络中有三种通讯模式：单播、广播、组播(多播)，其中的组播出现时间最晚但同时具备单播和广播的优点，最具有发展前景。 </p>
<h2 id="网络号"><a class="header" href="#网络号">网络号</a></h2>
<p>Internet上的每台主机和路由器都有一个IP地址，IP地址包含网络号和主机号，并且这种组合是唯一的。原则上，Internet上的任何两台机器不会有相同的IP地址。所有的IP地址都是32位长，被用于IP分组的源地址和目的地址域。
IP地址是一种分等级的地址结构，分为A、B、C、D、E五类，描述如下：</p>
<ul>
<li>A类地址的第一位总是0，8位分配给网络号，24位分配给主机号。</li>
<li>B类地址的前两位总是10，16位分配给网络号，16位分配给主机号。</li>
<li>C类地址的前三位总是110，24位分配给网络号，8位分配给主机号。</li>
<li>D类地址的前四位总是1110。</li>
<li>E类地址的前五位总是11110。</li>
</ul>
<p>网络号是由一个非营利性的机构来管理的，以避免冲突，该机构的名称为ICANN。同时，ICANN把部分地址空间委托给各种区域性的权威机构，然后这些权威机构又将IP地址分配给ISP和其他的公司。</p>
<p>IP地址分类方法的初衷是为路由协议的设计提供便利，只从IP地址的首部特征位就可以判定属于哪一类网络。但是这种分类方法使得地址空间无法得到最大限度的利用，随着互联网的急剧膨胀，地址短缺的问题愈来愈突出。</p>
<p>为了更大限度的使用IP地址，可将一个网络划分为多个子网，IP地址的结构变为三部分：网络号、子网号和主机号。网络号和子网号唯一标识一个网络。使用子网掩码确定IP地址中哪些部分属于网络号和子网号，哪些部分属于主机号。子网掩码为“1”的部分对应IP地址的网络号和子网号，为“0”的部分对应主机号。子网的划分提高了IP地址的利用率，在一定程度上缓解了IP地址短缺的问题。</p>
<h1 id="一些问题"><a class="header" href="#一些问题">一些问题</a></h1>
<h2 id="什么是svi和nat技术及其作用和作用范围"><a class="header" href="#什么是svi和nat技术及其作用和作用范围">什么是SVI和NAT技术及其作用和作用范围</a></h2>
<h3 id="交换机虚拟接口svi"><a class="header" href="#交换机虚拟接口svi">交换机虚拟接口SVI</a></h3>
<p>一个交换机虚拟接口（Switch Virtual Interface，SVI）代表一个由交换端口构成的VLAN（其实就是通常所说的VLAN接口），以便于实现系统中路由和桥接的功能。一个交换机虚拟接口对应一个VLAN，当需要路由虚拟局域网之间的流量或桥接VLAN之间不可路由的协议，以及提供IP主机到交换机的连接的时候，就需要为相应的虚拟局域网配置相应的交换机虚拟接口，其实SVI就是指通常所说的VLAN接口，只不过它是虚拟的，用于连接整个VLAN，所以通常也把这种接口称为逻辑三层接口，也是三层接口。SVI接口是当在interface vlan全局配置命令后面键入具体的VLAN ID时创建的。可以用no interface vlan vlan_id全局配置命令来删除对应的SVI接口，只是不能删除VLAN 1的SVI接口（VLAN 1），因为VLAN 1接口是默认已创建的，用于远程交换机管理。</p>
<p>应当为所有VLAN配置SVI接口，以便在VLAN间路由通信。也就是SVI接口的用途就是为VLAN间提供通信路由。</p>
<p>一个VLAN仅可以有一个SVI。在你希望在VLAN之间进行路由，或者在VLAN间进行非路由协议的fallback桥接，或者提供IP主机连接到交换机时，就需要为VLAN配置一个SVI。默认情况下，SVI是为默认VLAN（通常是VLAN 1）而创建的，以允许进行远程交换机管理。其他的SVI必须明确配置。所以说，SVI接口可以同时是该交换机的管理接口和下层设备的网关接口（路由连接口）。SVI提供到系统的IP主机连接。在三层模式中，可以配置通过SVI的路由。</p>
<p><strong>【说明】尽管交换机堆叠支持全部或最多1005个VLAN，这样理论上来说也就相当于可以有1005个SVI，但SVI数和可路由端口数，以及其他已配置的特征数之间的相互关系可能因硬件的局限性而影响CPU的性能。</strong></p>
<p>SVI是在你为VLAN接口第一次键入vlan接口配置命令时创建的。VLAN与ISL或IEEE 802.1q协议中封装的中继，或者访问端口配置的VLAN ID的数据帧相关联的VLAN标记相对应。如果需要路由VLAN间的通信，则需要为每个VLAN配置一个VLAN接口（也就是这里所说的SVI），并为每个SVI接口分配一个IP地址。有关SVI接口IP地址的分配方法将在本章后面介绍。</p>
<p>SVI具有自动状态排除（Autostate Exclude）特征。带有多个端口的VLAN上的SVI线路状态在SVI接口满足以下条件时呈开启状态：</p>
<ul>
<li>VLAN存在，并且在交换机的VLAN数据库中呈激活状态。</li>
<li>VLAN接口存在，并且是可管理的。</li>
<li>在VLAN中至少存在一个二层端口（访问端口或中继端口）的链路呈开启状态，并且这个链路在VLAN中是在生成树转发状态（Spanning-tree forwarding State）中。</li>
</ul>
<p>默认情况下，在一个VLAN有多个端口时，VLAN中的所有端口关闭后，SVI接口也将关闭。可以使用SVI自动状态排除特征来配置端口，使它不包括在SVI接口状态开关考虑范围内。例如，如果在VLAN中只有一个激活端口是镜像端口，则可以在该端口上配置自动状态排除，以便在所有其他端口关闭时关闭VLAN。在启用一个端口时，自动状态排除特征将应用到该端口上所连的所有已启用的VLAN中。</p>
<h3 id="nat技术"><a class="header" href="#nat技术">NAT技术</a></h3>
<p>网络地址转换(NAT,Network Address Translation)属接入广域网(WAN)技术,是一种将私有(保留)地址转化为合法IP地址的转换技术,它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p>
<p>虽然NAT可以借助于某些代理服务器来实现，但考虑到运算成本和网络性能，很多时候都是在路由器上来实现的。</p>
<p>随着接入Internet的计算机数量的不断猛增，IP地址资源也就愈加显得捉襟见肘。事实上，除了中国教育和科研计算机网(CERNET)外，一般用户几乎申请不到整段的C类IP地址。在其他ISP那里，即使是拥有几百台计算机的大型局域网用户，当他们申请IP地址时，所分配的地址也不过只有几个或十几个IP地址。显然，这样少的IP地址根本无法满足网络用户的需求，于是也就产生了NAT技术。</p>
<h4 id="nat简介"><a class="header" href="#nat简介">NAT简介</a></h4>
<p>借助于NAT，私有(保留)地址的&quot;内部&quot;网络通过路由器发送数据包时，私有地址被转换成合法的IP地址，一个局域网只需使用少量IP地址(甚至是1个)即可实现私有地址网络内所有计算机与Internet的通信需求。</p>
<p>NAT将自动修改IP报文的源IP地址和目的IP地址，Ip地址校验则在NAT处理过程中自动完成（对于ICMP，NAT也自动完成地址转换）。有些应用程序将源IP地址嵌入到IP报文的数据部分中，所以还需要同时对报文进行修改，以匹配IP头中已经修改过的源IP地址。否则，在报文数据都分别嵌入IP地址的应用程序就不能正常工作。</p>
<h4 id="nat实现方式"><a class="header" href="#nat实现方式">NAT实现方式</a></h4>
<p>NAT的实现方式有三种，即静态转换Static Nat、动态转换Dynamic Nat 和 端口多路复用OverLoad。</p>
<p>静态转换是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。借助于静态转换，可以实现外部网络对内部网络中某些特定设备(如服务器)的访问。</p>
<p>动态转换是指将内部网络的私有IP地址转换为公用IP地址时，IP地址对是不确定的，而是随机的，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式。</p>
<p>端口多路复用(Port address Translation,PAT)是指改变外出数据包的源端口并进行端口转换，即端口地址转换(PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</p>
<h4 id="受到nat影响的应用程序"><a class="header" href="#受到nat影响的应用程序">受到NAT影响的应用程序</a></h4>
<p>一些高层协议（比如FTP，Quake，SIP,VPN）是在IP包的有效数据内发送网络层（第三层）信息的。比如，主动模式的FTP使用单独的端口分别来控制命令传输和数据传输。当请求一个文件传输时，主机在发送请求的同时也通知对方自己想要在哪个端口接受数据。但是，如果主机是在一个简单的NAT防火墙后发送的请求，那么由于端口的映射将会使对方接收到的信息无效。</p>
<p>一个应用层网关（Application Layer Gateway或ALG）可以修正这个问题。运行在NAT防火墙设备上的ALG软件模块可以更新任何由地址转换而导致无效的信息。显然，ALG需要明白它所要修正的上层协议，所以每个有这种问题的协议都需要有一个单独的ALG。
　　但是，除FTP外的大多数传统的客户机－服务器协议不需要发送网络层（第三层）信息，也就不需要ALG。
　　这个问题的另一个可能的解决方法是使用象STUN这样的技术，但是这只针对建立在UDP上的高层协议，并且需要它内建这种技术。这种技术对对称NAT也是无效的。还有一种可能的方案是UPnP，但它需要和NAT设备配合起来使用.</p>
<h4 id="工作原理"><a class="header" href="#工作原理">工作原理</a></h4>
<p>当一台小型商务企业的内部网计算机用户连接到 Internet 资源时，该用户的 TCP/IP 协议产生一个 IP 数据包，该数据包包含以下值，这些值位于 IP 和 TCP 或 UDP 标头中：(粗体内容表示受 NAT 影响的项目)：
　　</p>
<ul>
<li>目标 IP 地址：Internet 资源 IP 地址</li>
<li>源 IP 地址：私有 IP 地址</li>
<li>目标端口：Internet 资源 TCP 或 UDP 端口</li>
<li>源端口: 源应用程序 TCP 或 UDP 端口</li>
</ul>
<p>请求源主机或者其它路由器将此 IP 数据包发送给 NAT, 然后由 NAT 将向外发送的数据包的地址解析如下：
　　</p>
<ul>
<li>目标IP地址：Internet 资源 IP 地址</li>
<li>源IP 地址：ISP 分配的公用地址</li>
<li>目标端口：Internet 资源 TCP 或 UDP 端口</li>
<li>源端口：重新映射的源应用程序TCP 或 UDP 端口</li>
</ul>
<p>NAT 将重新映射的 IP 数据包发送到 Internet 。响应计算机将向 NAT 返回一个响应。当 NAT 接收到此响应时，该数据包将包含以下地址信息：
　　</p>
<ul>
<li>目标IP 地址：ISP 分配的公用地址</li>
<li>源IP地址：Internet 资源 IP 地址</li>
<li>目标端口：重新映射的源应用程序 TCP 或 UDP 端口</li>
<li>源端口：Internet 资源的 TCP 或者 UDP 端口</li>
</ul>
<p>当 NAT 完成映射和解析地址后，将向 Internet 客户端发送数据包，此数据包包含以下地址信息：
　　</p>
<ul>
<li>目标 IP 地址：私有 IP 地址</li>
<li>源 IP 地址：Internet 资源 IP 地址</li>
<li>目标端口：源应用程序TCP 或者 UDP 端口</li>
<li>源端口：Internet 资源 TCP 或 UDP 端口</li>
</ul>
<p>对于向外发送的数据包，源 IP 地址和 TCP/UDP 端口号将被映射到一个公用源 IP 地址和一个可能变化的 TCP/UDP端口号。对于接收的数据包，目标 IP 地址和 TCP/UDP 端口号将被映射到私有 IP 地址和初始 TCP/UDP 端口号。</p>
<p>那么，NAT转换表何时进行初始化呢，一般有三种方式：手工初始化，外发数据报时，传入名字查找。大多数NAT实现方式都使用外发数据报时初始化转换表，当内部主机通过NAT向外发送数据报时，NAT此时在转换表中创建一个表项。 </p>
<h2 id="什么是直连路由静态路由和默认路由"><a class="header" href="#什么是直连路由静态路由和默认路由">什么是直连路由，静态路由和默认路由</a></h2>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<ol>
<li>直连路由
直连路由是由链路层协议发现的，一般指去往路由器的接口地址所在网段的路径，直连路由无需手工配置，只要接口配置了网络协议地址同时管理状态、物理状态和链路协议均为UP时，路由器能够自动感知该链路存在，接口上配置的IP网段地址会自动出现在路由表中且与接口关联，并动态随接口状态变化在路由表中自动出现或消失。</li>
<li>静态路由
静态路由是由网络管理员根据网络拓扑，使用命令在路由器上配置的路由，这些静态路由信息指导报文发送，静态路由方式也无需路由器进行计算，但它完全依赖于网络管理员的手动配置。补充一下，默认路由是一种特殊的静态路由，网络管理员手工配置了默认路由后，当路由表中与目的地址之间没有匹配的表项时路由器将把数据包发送给默认网关。</li>
<li>动态路由</li>
</ol>
<p>动态路由是指路由器能够自动地建立自己的路由表，且能根据网络拓扑状态变化进行动态调整。动态路由机制依赖于对路由表的维护以及路由器间动态的路由信息交换。路由器间的路由信息交换是基于路由协议实现的，交换路由信息的最终目的是通过路由表找到“最佳”路由。</p>
<h3 id="三种路由的区别"><a class="header" href="#三种路由的区别">三种路由的区别</a></h3>
<p>主要从三种路由的优缺点及使用场合来加以区别：</p>
<ol>
<li>
<p>直连路由
没什么好说的了，直连路由只能使用于直接相连的路由器端口，非直连的路由器端口是没有直连路由的。</p>
</li>
<li>
<p>静态路由
静态路由信息在缺省情况下是私有的，不会传递给其他的路由器。当然，网络管理员也可通过对路由器设置使之成为共享的。网络管理员易于清楚地了解网络的拓扑结构，便于设置正确的路由信息。静态路由一般适用于较简单的网络环境。</p>
</li>
<li>
<p>动态路由
当网络规模较大或网络拓扑经常发生改变时，此时宜采用动态路由的方式，路由器能够按照相关路由算法自动计算新的路由信息，适应网络拓扑结构的变化。大型和复杂的网络环境通常不宜采用静态路由。网络管理员难以全面地了解整个网络拓扑，同时当网络拓扑和链路状态发生变化时，路由器中的静态路由信息需要大范围地调整，这一工作的难度和复杂程度非常高，所以宜采用动态路由的方式。</p>
</li>
</ol>
<h2 id="ip协议的报文格式"><a class="header" href="#ip协议的报文格式">IP协议的报文格式</a></h2>
<p>TCP/IP协议采用分层结构，其分层模型及协议如下表：</p>
<table><thead><tr><th>层级</th><th>协议</th></tr></thead><tbody>
<tr><td>应用层(Application)</td><td>HTTP、Telnet、FTP、SMTP、SNMP</td></tr>
<tr><td>传输层(Transport)</td><td>TCP、UDP</td></tr>
<tr><td>网间网层(Internet)</td><td>IP【ARP、RARP、ICMP】</td></tr>
<tr><td>网络接口层(Network)</td><td>Ethernet、X.25、SLIP、PPP</td></tr>
</tbody></table>
<p>IP 协议报头
<img src="https://zhangbinalan.gitbooks.io/protocol/content/Center.gif" alt="IP 协议报头" /></p>
<p>固定首部长度为20字节,可变部分0~40字节,各字段解释：</p>
<ol>
<li>源端口，16bits，范围0~65525。</li>
<li>目的端口，16bits，范围同上。</li>
<li>sequence number： 数据序号，32bits，TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li>
<li>acknoledgement number： 确认号，32bits，期望收到对方的下一个报文段的数据的第一个字节的序号。</li>
<li>数据偏移，4bits，单位为4字节，它指出报文数据距TCP报头的起始处有多远(TCP报文头长度)。</li>
<li>保留字段 6bits，保留今后使用，目前置0处理。</li>
<li>数据连续比特位：
<ul>
<li>URG：紧急比特，1bit，当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</li>
<li>ACK：确认比特，1bit，只有当 ACK=1时确认号字段才有效。当 ACK=0 时，确认号无效</li>
<li>PSH：推送比特，1bit，接收方 TCP 收到推送比特置1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付</li>
<li>RST：复位比特，1bit，当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接</li>
<li>SYN：同步比特，1bit，同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文</li>
<li>FIN：终止比特，1bit，用来释放一个连接。当FIN=1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</li>
</ul>
</li>
<li>窗口大小，16bits，窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</li>
<li>检验和，16bits，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li>
<li>紧急指针字段，16bits，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。</li>
<li>选项字段，长度可变。TCP首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项。 这部分最多包含40字节，因为TCP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）</li>
</ol>
<p>选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段info（如果有的话）是选项的具体信息. kind=0是选项表结束选项
kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍
kind=2是最大报文段长度选项,TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。</p>
<h2 id="什么是acl技术"><a class="header" href="#什么是acl技术">什么是ACL技术</a></h2>
<p>访问控制列表ACL技术
ACL技术在路由器中被广泛采用，它是一种基于包过滤的流控制技术。控制列表通过把源地址、目的地址及端口号作为数据包检查的基本元素，并可以规定符合条件的数据包是否允许通过。ACL通常应用在企业的出口控制上，可以通过实施ACL，可以有效的部署企业网络出网策略。随着局域网内部网络资源的增加，一些企业已经开始使用ACL来控制对局域网内部资源的访问能力，进而来保障这些资源的安全性。</p>
<p>ACL技术可以有效的在三层上控制网络用户对网络资源的访问，它可以具体到两台网络设备间的网络应用，也可以按照网段进行大范围的访问控制管理，为网络应用提供了一个有效的安全手段。</p>
<p>一方面，采用ACL技术，网络管理员需要明确每一台主机及工作站所在的IP子网并确认它们之间的访问关系，适用于网络终端数量有限的网络。对于大型网络，为了完成某些访问控制甚至不得不浪费很多的IP地址资源。同时，巨大的网络终端数量，同样会增加管理的复杂度和难度。另一方面，维护ACL不仅耗时，而且在较大程度上增加路由器开销。访问控制列表的策略性非常强，并且牵涉到网络的整体规划，它的使用对于策略制定及网络规划的人员的技术素质要求比较高。因此，是否采用ACL技术及在多大的程度上利用它，是管理效益与网络安全之间的一个权衡。</p>
<p>访问控制列表从概念上来讲并不复杂，复杂的是对它的配置和使用，许多初学者往往在使用访问控制列表时出现错误。</p>
<h1 id="预习报告"><a class="header" href="#预习报告">预习报告</a></h1>
<h2 id="osi网络模型每层结构传输单元及其包含的协议"><a class="header" href="#osi网络模型每层结构传输单元及其包含的协议">OSI网络模型每层结构传输单元及其包含的协议</a></h2>
<p><img src="media/OSI.gif" alt="OSI" /></p>
<table><thead><tr><th>数据单元</th><th>层</th></tr></thead><tbody>
<tr><td>Data（数据）</td><td>应用层、表示层、会话层</td></tr>
<tr><td>Segments（数据段）</td><td>传输层</td></tr>
<tr><td>Datagram网络分组/数据报文</td><td>网络层</td></tr>
<tr><td>Bit/Frame（数据帧）</td><td>数据链路层</td></tr>
<tr><td>Bit（比特）</td><td>物理层</td></tr>
</tbody></table>
<h2 id="理解性写出广播域冲突域广播风暴的概念"><a class="header" href="#理解性写出广播域冲突域广播风暴的概念">理解性写出广播域，冲突域，广播风暴的概念</a></h2>
<ol>
<li>广播域
广播域是计算机网络的一个逻辑划分。广播域中的任意一个节点可以在数据链路层通过广播的方式到达任意一个节点。广播域可以被部署在同一个局域网或者被桥接到其他的局域网。根据目前的流行技术，任意连接到同一个以太网中继器或者交换机的电脑属于同一个广播域，并且任意连接到同一个互相链接的中继器或交换机的集合的电脑也是属于同一个广播域的。而路由器和其他的网络层设备会在广播域间形成隔离。</li>
<li>冲突域
与广播域相对的是冲突域。冲突域中所有节点都链接到同一个被交换机和学习型网桥划分的相互连接的中继器集合。冲突域一般来说小于或者包含在广播域中。 一些处在数据链路层的设备能够划分冲突域，但是广播域只能由像路由器或者网络层交换机这样的网络层的设备来进行划分。虚拟局域网设备也能划分广播域，但是它们只能在网络层的功能下提供这些子域的网络方法。</li>
<li>广播风暴
广播风暴（broadcast storm）简单的讲是指当广播数据充斥网络无法处理，并占用大量网络带宽，导致正常业务不能运行，甚至彻底瘫痪，这就发生了“广播风暴”。一个数据帧或包被传输到本地网段 （由广播域定义）上的每个节点就是广播；由于网络拓扑的设计和连接问题，或其他原因导致广播在网段内大量复制，传播数据帧，导致网络性能下降，甚至网络瘫痪，这就是广播风暴。</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="SC-concept.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="linux-socket.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="SC-concept.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="linux-socket.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="mermaid.min.js"></script>
                <script type="text/javascript" src="mermaid-init.js"></script>
        
        
    </body>
</html>
