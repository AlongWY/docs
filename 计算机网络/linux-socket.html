<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linux Socket编程 - 啸雨听风</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../SUMMARY.html">目录</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> 形式语言与自动机</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../形式语言与自动机/FLA-Base.html"><strong aria-hidden="true">1.1.</strong> 形式语言与自动机基础</a></li><li class="chapter-item expanded "><a href="../形式语言与自动机/FLA-Regular.html"><strong aria-hidden="true">1.2.</strong> 形式语言与自动机之正则语言</a></li><li class="chapter-item expanded "><a href="../形式语言与自动机/FLA-PDA.html"><strong aria-hidden="true">1.3.</strong> 形式语言与自动机之上下文无关语言</a></li><li class="chapter-item expanded "><a href="../形式语言与自动机/BNF-EBNF.html"><strong aria-hidden="true">1.4.</strong> BNF和EBNF的含义及其用法</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 算法设计与分析</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../算法设计与分析/Algorithms-Analysis.html"><strong aria-hidden="true">2.1.</strong> 算法之算法分析</a></li><li class="chapter-item expanded "><a href="../算法设计与分析/Algorithms-Greedy.html"><strong aria-hidden="true">2.2.</strong> 算法之贪心法</a></li><li class="chapter-item expanded "><a href="../算法设计与分析/Algorithms-DC.html"><strong aria-hidden="true">2.3.</strong> 算法之分治法</a></li><li class="chapter-item expanded "><a href="../算法设计与分析/Algorithms-DP.html"><strong aria-hidden="true">2.4.</strong> 算法之动态规划</a></li><li class="chapter-item expanded "><a href="../算法设计与分析/Algorithms-Search.html"><strong aria-hidden="true">2.5.</strong> 算法之搜索策略</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 机器学习</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../机器学习/ML-prepare-math.html"><strong aria-hidden="true">3.1.</strong> 机器学习-数学预备知识</a></li><li class="chapter-item expanded "><a href="../机器学习/ML-decision-tree.html"><strong aria-hidden="true">3.2.</strong> 机器学习-决策树</a></li><li class="chapter-item expanded "><a href="../机器学习/ML-LogisticRegression.html"><strong aria-hidden="true">3.3.</strong> 机器学习-逻辑回归</a></li><li class="chapter-item expanded "><a href="../机器学习/ML-LinnerModel.html"><strong aria-hidden="true">3.4.</strong> 机器学习-线性模型</a></li><li class="chapter-item expanded "><a href="../机器学习/ML-GMM-Kmeans.html"><strong aria-hidden="true">3.5.</strong> 机器学习-GMM模型与EM算法</a></li><li class="chapter-item expanded "><a href="../机器学习/ML-PCA.html"><strong aria-hidden="true">3.6.</strong> 机器学习-主成分分析</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 软件构造</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../软件构造/SC-Base.html"><strong aria-hidden="true">4.1.</strong> 软件构造基础</a></li><li class="chapter-item expanded "><a href="../软件构造/SC-concept.html"><strong aria-hidden="true">4.2.</strong> 软件构造-概念辨析</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 计算机网络</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../计算机网络/about-net.html"><strong aria-hidden="true">5.1.</strong> 计算机网络基本概念</a></li><li class="chapter-item expanded "><a href="../计算机网络/linux-socket.html" class="active"><strong aria-hidden="true">5.2.</strong> Linux Socket编程</a></li><li class="chapter-item expanded "><a href="../计算机网络/wireshark.html"><strong aria-hidden="true">5.3.</strong> Wireshark解决权限问题</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 编程语言</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> NASM</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../编程语言/using-nasm.html"><strong aria-hidden="true">6.1.1.</strong> NASM的安装与使用</a></li><li class="chapter-item expanded "><a href="../编程语言/nasm-tutorial.html"><strong aria-hidden="true">6.1.2.</strong> NASM 教程 -- 从HelloWorld说开去</a></li></ol></li><li class="chapter-item expanded "><a href="../编程语言/julia-learn.html"><strong aria-hidden="true">6.2.</strong> JuliaLang 学习</a></li><li class="chapter-item expanded "><a href="../编程语言/boost-python.html"><strong aria-hidden="true">6.3.</strong> Boost::Python 教程</a></li><li class="chapter-item expanded "><a href="../编程语言/latex-circuitikz.html"><strong aria-hidden="true">6.4.</strong> Latex-Circuitikz绘制电路图</a></li><li class="chapter-item expanded "><a href="../编程语言/why-is-INT-MAX-1.html"><strong aria-hidden="true">6.5.</strong> 为什么是-INT_MAX-1</a></li><li class="chapter-item expanded "><a href="../编程语言/pandoc-markdown.html"><strong aria-hidden="true">6.6.</strong> Pandoc's 的 Markdown 语法拓展</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 操作系统</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../操作系统/win-linux-double-system.html"><strong aria-hidden="true">7.1.</strong> 安装Windows和Linux双系统</a></li><li class="chapter-item expanded "><a href="../操作系统/install-Manjaro.html"><strong aria-hidden="true">7.2.</strong> 配置安装Linux/Manjaro</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 杂项</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Django</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../杂项/django-database-separate.html"><strong aria-hidden="true">8.1.1.</strong> Django 多数据库联用</a></li><li class="chapter-item expanded "><a href="../杂项/django-restfulramework-drf-haystack-whoosh.html"><strong aria-hidden="true">8.1.2.</strong> Django里使用全文搜索框架drf_haystack</a></li></ol></li><li class="chapter-item expanded "><a href="../杂项/spring-boot-start.html"><strong aria-hidden="true">8.2.</strong> Spring Boot起步</a></li><li class="chapter-item expanded "><a href="../杂项/compile-lantern.html"><strong aria-hidden="true">8.3.</strong> 编译安装不限流量的Lantern</a></li><li class="chapter-item expanded "><a href="../杂项/hexo-github.html"><strong aria-hidden="true">8.4.</strong> Travis CI + Hexo部署你的博客</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">啸雨听风</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<!-- ---
title: Linux Socket编程
tags:
  - Linux
  - Socket
date: 2017-09-10 10:42:44
categories: 教程
--- -->
<h1 id="序"><a class="header" href="#序">序</a></h1>
<p>现在是网络的时代，不懂一点网络编程出去到不好意思跟人打招呼，Socket应该是当前网络编程的基础，今天来看一下Linux下的Socket编程。</p>
<!-- more -->
<h1 id="tcpip"><a class="header" href="#tcpip">TCP/IP</a></h1>
<p>Socket是建立在TCP/IP上的，所以想要理解Socket最好先熟悉一下TCP/IP协议族。</p>
<p>TCP/IP协议共有四层，每一层抽象建立在低一层提供的服务上，并且为高一层提供服务。</p>
<ul>
<li><strong>应用层</strong>：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等</li>
<li><strong>传输层</strong>：TCP，UDP</li>
<li><strong>网络层</strong>：IP，ICMP，OSPF，EIGRP，IGMP</li>
<li><strong>数据链路层</strong>：SLIP，CSLIP，PPP，MTU</li>
</ul>
<p>更详细的内容可以参考<a href="https://zh.wikipedia.org/wiki/TCP/IP">维基百科</a>或者<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE?fromId=7729">百度百科</a>。</p>
<h1 id="socket"><a class="header" href="#socket">Socket</a></h1>
<p>我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。</p>
<p>能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p>
<p>socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种&quot;打开—读/写—关闭&quot;模式的实现，服务器和客户端各自维护一个&quot;文件&quot;，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p>
<h2 id="socket通信流程"><a class="header" href="#socket通信流程">Socket通信流程</a></h2>
<ol>
<li>服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket</li>
<li>服务器为socket绑定ip地址和端口号</li>
<li>服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开</li>
<li>客户端创建socket</li>
<li>客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket</li>
<li>服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端连接请求</li>
<li>客户端连接成功，向服务器发送连接状态信息</li>
<li>服务器accept方法返回，连接成功</li>
<li>客户端向socket写入信息</li>
<li>服务器读取信息</li>
<li>客户端关闭</li>
<li>服务器端关闭</li>
</ol>
<h2 id="三次握手"><a class="header" href="#三次握手">三次握手</a></h2>
<p>在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接</p>
<ul>
<li>
<p><strong>第一次握手</strong>：客户端尝试连接服务器，向服务器发送syn包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入SYN_SEND状态等待服务器确认</p>
</li>
<li>
<p><strong>第二次握手</strong>：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态</p>
</li>
<li>
<p><strong>第三次握手</strong>：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p>
</li>
</ul>
<h1 id="socket编程api"><a class="header" href="#socket编程api">Socket编程API</a></h1>
<h2 id="创建socket--socket函数"><a class="header" href="#创建socket--socket函数">创建socket--socket函数</a></h2>
<p><strong>函数原型</strong>:</p>
<pre><code class="language-c">int socket(int domain, int type, int protocol);
</code></pre>
<p><strong>参数说明</strong>:</p>
<ul>
<li><strong>domain</strong>： 协议域，又称协议族（family）。常用的协议族有 AF_INET 、 AF_INET6 、 AF_LOCAL（或称AF_UNIX，Unix域Socket）、AF_ROUTE 等。协议族决定了 socket 的地址类型，在通信中必须采用对应的地址，如 AF_INET 决定了要用 ipv4 地址（32位的）与端口号（16位的）的组合、AF_UNIX 决定了要用一个绝对路径名作为地址。</li>
<li><strong>type</strong>： 指定 Socket 类型。常用的 socket 类型有 SOCK_STREAM 、 SOCK_DGRAM 、 SOCK_RAW 、 SOCK_PACKET 、 SOCK_SEQPACKET 等。流式 Socket（SOCK_STREAM）是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用。数据报式 Socket（SOCK_DGRAM）是一种无连接的 Socket，对应于无连接的 UDP 服务应用。</li>
<li><strong>protocol</strong>： 指定协议。常用协议有 IPPROTO_TCP 、 IPPROTO_UDP 、 IPPROTO_STCP 、 IPPROTO_TIPC 等，分别对应 TCP 传输协议、UDP 传输协议、STCP 传输协议、TIPC 传输协议。</li>
</ul>
<p><strong>注意：type 和 protocol 不可以随意组合，如 SOCK_STREAM 不可以跟 IPPROTO_UDP 组合。当第三个参数为0时，会自动选择第二个参数类型对应的默认协议。</strong></p>
<p><strong>返回值</strong>:
如果调用成功就返回新创建的套接字的描述符，如果失败就返回INVALID_SOCKET（Linux下失败返回-1）。</p>
<p>套接字描述符是一个整数类型的值。每个进程的进程空间里都有一个套接字描述符表，该表中存放着套接字描述符和套接字数据结构的对应关系。该表中有一个字段存放新创建的套接字的描述符，另一个字段存放套接字数据结构的地址，因此根据套接字描述符就可以找到其对应的套接字数据结构。每个进程在自己的进程空间里都有一个套接字描述符表但是套接字数据结构都是在操作系统的内核缓冲里。</p>
<h2 id="命名socket--bind函数"><a class="header" href="#命名socket--bind函数">命名socket--bind函数</a></h2>
<p>bind()函数把一个地址族中的特定地址赋给socket。例如对应 AF_INET、AF_INET6 就是把一个 ipv4 或 ipv6 地址和端口号组合赋给socket。</p>
<p><strong>函数原型</strong>:</p>
<pre><code class="language-c">int bind(int socketfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>
<p><strong>参数说明</strong>:</p>
<ul>
<li><strong>socketfd</strong>： 一个标识已连接套接口的描述字。</li>
<li><strong>address</strong>： 是一个sockaddr结构指针，该结构中包含了要结合的地址和端口号。</li>
<li><strong>address_len</strong>： 确定 address 缓冲区的长度。</li>
</ul>
<p><strong>其中 sockaddr 这个地址结构根据地址创建 socket 时的地址协议族的不同而不同。</strong></p>
<p>如ipv4对应的是：</p>
<pre><code class="language-c">struct sockaddr_in {
    sa_family_t    sin_family; /* address family: AF_INET */
    in_port_t      sin_port;   /* port in network byte order */
    struct in_addr sin_addr;   /* internet address */
};
/* Internet address. */
struct in_addr {
    uint32_t       s_addr;     /* address in network byte order */
};
</code></pre>
<p>ipv6对应的是：</p>
<pre><code class="language-c">struct sockaddr_in6 {
    sa_family_t     sin6_family;   /* AF_INET6 */
    in_port_t       sin6_port;     /* port number */
    uint32_t        sin6_flowinfo; /* IPv6 flow information */
    struct in6_addr sin6_addr;     /* IPv6 address */
    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */
};
struct in6_addr {
    unsigned char   s6_addr[16];   /* IPv6 address */
};
</code></pre>
<p>Unix域对应的是：</p>
<pre><code class="language-c">#define UNIX_PATH_MAX    108
struct sockaddr_un {
    sa_family_t sun_family;               /* AF_UNIX */
    char        sun_path[UNIX_PATH_MAX];  /* pathname */
};
</code></pre>
<p><strong>返回值</strong>:如果函数执行成功，返回值为0，否则为SOCKET_ERROR。</p>
<h2 id="监听socket--listen函数"><a class="header" href="#监听socket--listen函数">监听socket--listen函数</a></h2>
<p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<p><strong>函数原型</strong>:</p>
<pre><code class="language-c">int listen(int socketfd, int backlog);
</code></pre>
<p><strong>参数说明</strong>:</p>
<ul>
<li><strong>socketfd</strong>： 要监听的socket的描述字。</li>
<li><strong>backlog</strong>： 相应socket可以排队的最大连接个数。</li>
</ul>
<p>socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<h2 id="建立连接--connect函数"><a class="header" href="#建立连接--connect函数">建立连接--connect函数</a></h2>
<p>服务端已经做好被动接受连接的准备，那么客户端需要调用如下函数主动连接服务端，客户端利用connect函数连接服务端，如果连接成功后，其第一个参数sockfd就唯一标示这个连接。</p>
<p><strong>函数原型</strong>:<code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p>
<p><strong>参数说明</strong>:</p>
<ul>
<li><strong>socketfd</strong>： 客户端socket的描述字。</li>
<li><strong>sockaddr</strong>: 服务器的socket地址。</li>
<li><strong>addrlen</strong>: socket地址的长度</li>
</ul>
<h2 id="接受连接--accept函数"><a class="header" href="#接受连接--accept函数">接受连接--accept函数</a></h2>
<p>TCP服务器端依次调用 socket()、bind()、listen() 之后，就会监听指定的 socket 地址了。
TCP客户端依次调用 socket()、connect() 之后就向 TCP 服务器发送了一个连接请求。
TCP 服务器监听到这个请求之后，就会调用 accept() 函数取接收请求，这样连接就建立好了。
之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p>
<p><strong>函数原型</strong>:</p>
<pre><code class="language-c">int accept(int socketfd, struct sockaddr *addr, socklen_t *addrlen); //返回连接connect_fd
</code></pre>
<p><strong>参数说明</strong>:</p>
<ul>
<li><strong>socketfd</strong>: 就是上面解释中的监听套接字，这个套接字用来监听一个端口，当有一个客户与服务器连接时，它使用这个一个端口号，而此时这个端口号正与这个套接字关联。当然客户不知道套接字这些细节，它只知道一个地址和一个端口号。</li>
<li><strong>sockaddr</strong>: 结果参数，它用来接受一个返回值，这返回值指定客户端的地址，当然这个地址是通过某个地址结构来描述的，用户应该知道这一个什么样的地址结构。如果对客户的地址不感兴趣，那么可以把这个值设置为NULL。</li>
<li><strong>len</strong>: 它也是结果的参数，用来接受上述 addr 的结构的大小的，它指明 addr 结构所占有的字节个数。同样的，它也可以被设置为NULL。</li>
</ul>
<p><strong>返回值</strong>：成功返回客户端的文件描述符，失败返回-1。</p>
<ul>
<li>如果accept成功返回，则服务器与客户已经正确建立连接了，此时服务器通过accept返回的套接字来完成与客户的通信。</li>
<li>accept默认会阻塞进程，直到有一个客户连接建立后返回，它返回的是一个新可用的套接字，这个套接字是连接套接字。</li>
</ul>
<p><strong>监听套接字</strong>：监听套接字是在调用listen函数之后，是服务器开始调用socket()函数生成的，称为监听socket描述字(监听套接字)。
<strong>连接套接字</strong>：accept函数返回的是已连接socket描述字(一个连接套接字)，它代表着网络中已经建立好的socket连接。</p>
<p>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。
连接套接字socketfd_new 并没有占用新的端口与客户端通信，依然使用的是与监听套接字socketfd一样的端口号。</p>
<h2 id="数据通信--readwrite等函数"><a class="header" href="#数据通信--readwrite等函数">数据通信--read()、write()等函数</a></h2>
<pre><code class="language-c">#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                struct sockaddr *src_addr, socklen_t *addrlen);

ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
</code></pre>
<p><strong>read</strong>函数是负责从fd中读取内容，返回值如下：</p>
<ul>
<li><strong>返回值大于0</strong>：说明读取成功，返回值是实际所读的字节数</li>
<li><strong>返回值等于0</strong>：表示已经读到文件的末尾</li>
<li><strong>返回值小于0</strong>：读取失败</li>
</ul>
<p><strong>如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</strong></p>
<p><strong>write</strong>函数将buf中的nbytes字节内容写入文件描述符fd，返回值说明如下：</p>
<ul>
<li><strong>返回值大于0</strong>：说明写入成功，返回值是实际写入的字节数</li>
<li><strong>返回值小于0</strong>：写入失败，并设置errno变量</li>
</ul>
<p>在网络程序中，当我们向套接字文件描述符写时有俩种可能:</p>
<ol>
<li>write的返回值大于0，表示写了部分或者是全部的数据。</li>
<li>返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</li>
</ol>
<h2 id="关闭连接--close函数"><a class="header" href="#关闭连接--close函数">关闭连接--close函数</a></h2>
<p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字。</p>
<p><strong>函数原型</strong>：</p>
<pre><code class="language-c">int close(int fd);
</code></pre>
<p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p>
<p><strong>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</strong></p>
<h2 id="select-函数说明"><a class="header" href="#select-函数说明">Select 函数说明</a></h2>
<p><strong>Select函数用于判断Socket是否已经关闭</strong></p>
<p><strong>函数原型</strong>:<code>int select(int nfds,fd_set *readfds, fd_set *writefds,fdset *exceptfds,const struct timval *timeout);</code></p>
<p><strong>参数说明</strong>:</p>
<ul>
<li><strong>nfds</strong>： 忽略。</li>
<li><strong>readfds</strong>: 检查可读性。</li>
<li><strong>writefds</strong>: 检查可些性。</li>
<li><strong>exceptfds</strong>: 用于例外数据。</li>
<li><strong>timeout</strong>: 超时时间，传递NULL无限等待，0立刻返回。</li>
</ul>
<h3 id="可读性说明"><a class="header" href="#可读性说明">可读性说明：</a></h3>
<ol>
<li>有数据可以读入。</li>
<li>连接已经关闭，重设或者中止。</li>
<li>加入调用了listen，而且一个连接正在建立，那么accept函数调用会成功。</li>
</ol>
<p>关于连接已经关闭，重设或者中止的判断：
当一个套接字在调用了select之后具有可读性，那么这个时候我们可以通过调用recv获得数据。如果真的有数据发送过来，那么这个调用会成功。如果是关闭，重设或者中止，那么recv的调用会失败，这个时候通过wsagetlasterror就可以判断连接是否已经中断。</p>
<h3 id="可写性说明"><a class="header" href="#可写性说明">可写性说明：</a></h3>
<ol>
<li>有数据可以发出。</li>
<li>如果已完成了对一个非锁定连接调用处理，连接就会成功。</li>
<li></li>
</ol>
<p>对于可写性的检查，最好放在需要写数据的时候进行检查。如果和可读性放在同一个地方进行检查，那么select很可能每次都会因为可写性检查成功而返回。</p>
<h3 id="例外数据说明"><a class="header" href="#例外数据说明">例外数据说明：</a></h3>
<ol>
<li>加入已完成了对一个非锁定连接调用的处理，连接尝试就会失败。</li>
<li>有带外数据可供读写。</li>
</ol>
<h3 id="fd_set几个宏的说明"><a class="header" href="#fd_set几个宏的说明">fd_set几个宏的说明：</a></h3>
<table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody>
<tr><td>FD_SETSIZE</td><td>定义了fd_set所允许存放套接字的最大个数，默认是64</td></tr>
<tr><td>FD_CLR(s,*set)</td><td>从set中删除套接字s</td></tr>
<tr><td>FD_ISSET(s, *set)</td><td>检查s是否set集合的一名成员；如答案是肯定的是，则返回TRUE</td></tr>
<tr><td>FD_SET(s, *set)</td><td>将套接字s加入集合set</td></tr>
<tr><td>FDZERO(*set)</td><td>将set初始化成空集合</td></tr>
</tbody></table>
<h3 id="select调用流程"><a class="header" href="#select调用流程">select调用流程：</a></h3>
<ol>
<li>使用FDZERO宏，初始化自己感兴趣的每一个fd_set。</li>
<li>使用FDSET宏，将套接字句柄分配给自己感兴趣的每个fd_set。</li>
<li>调用select函数，然后等待在指定的fd_set集合中，I/O活动设置好一个或多个套接字句柄。select完成后，会返回在所有fd_set集合中设置的套接字句柄总数，它会修改每个fd_set结构，删除那些不存在待决I/O操作的套接字句柄</li>
<li>根据select的返回值，我们的应用程序便可判断出哪些套接字存在着尚未完成（待决）的I/O操作—具体的方法是使用FD_ISSET宏，对每个fd_set集合进行检查。</li>
<li>知道了每个集合中“待决”的I/O操作之后，对I/O进行处理，然后返回步骤1，继续进行select处理。</li>
</ol>
<h1 id="socket编程的其他函数说明"><a class="header" href="#socket编程的其他函数说明">socket编程的其他函数说明</a></h1>
<h2 id="网络字节顺序及其转换函数"><a class="header" href="#网络字节顺序及其转换函数">网络字节顺序及其转换函数</a></h2>
<ol>
<li>
<p>网络字节顺序
每一台机器内部对变量的字节存储顺序不同，而网络传输的数据是一定要统一顺序的。所以对内部字节表示顺序与网络字节顺序不同的机器，
一定要对数据进行转换，从程序的可移植性要求来讲，就算本机的内部字节表示顺序与网络字节顺序相同也应该在传输数据以前先调用数据转换函数，
以便程序移植到其它机器上后能正确执行。真正转换还是不转换是由系统函数自己来决定的。</p>
</li>
<li>
<p>有关的转换函数</p>
</li>
<li></li>
</ol>
<pre><code class="language-c">#include &lt;netinet/in.h&gt;
unsigned short int htons(unsigned short int hostshort);
//主机字节顺序转换成网络字节顺序，对无符号短型进行操作4bytes

unsigned long int htonl(unsigned long int hostlong);
//主机字节顺序转换成网络字节顺序，对无符号长型进行操作8bytes

unsigned short int ntohs(unsigned short int netshort);
//网络字节顺序转换成主机字节顺序，对无符号短型进行操作4bytes

unsigned long int ntohl(unsigned long int netlong);
//网络字节顺序转换成主机字节顺序，对无符号长型进行操作8bytes
</code></pre>
<h2 id="ip地址转换"><a class="header" href="#ip地址转换">IP地址转换</a></h2>
<p>有三个函数将数字点形式表示的字符串IP地址与32位网络字节顺序的二进制形式的IP地址进行转换：</p>
<pre><code class="language-c">1. unsigned long int inet_addr(const char cp);
//该函数把一个用数字和点表示的IP地址的字符串转换成一个无符号长整型

//该函数成功时：返回转换结果；失败时返回常量INADDR_NONE，该常量=-1，二进制的无符号整数-1相当于255.255.255.255，这是一个广播地址，所以在程序中调用iner_addr（）时，一定要人为地对调用失败进行处理。由于该函数不能处理广播地址，所以在程序中应该使用函数inet_aton（）。

2. int inet_aton(const char cp,struct in_addr inp);
//此函数将字符串形式的IP地址转换成二进制形式的IP地址；成功时返回1，否则返回0，转换后的IP地址存储在参数inp中。

3. char inet_ntoa(struct in-addr in);
//将32位二进制形式的IP地址转换为数字点形式的IP地址，结果在函数返回值中返回，返回的是一个指向字符串的指针。
</code></pre>
<h2 id="字节处理函数"><a class="header" href="#字节处理函数">字节处理函数</a></h2>
<p>Socket地址是多字节数据，不是以空字符结尾的，这和C语言中的字符串是不同的。Linux提供了两组函数来处理多字节数据，一组以b（byte）开头，是和BSD系统兼容的函数，另一组以mem（内存）开头，是ANSI C提供的函数。
以b开头的函数有：</p>
<pre><code class="language-c">#include &lt;strings.h&gt;
void bzero(void s,int n);
//将参数s指定的内存的前n个字节设置为0，通常它用来将套接字地址清0。
void bcopy(const void src，void dest，int n);
//从参数src指定的内存区域拷贝指定数目的字节内容到参数dest指定的内存区域。
int bcmp(const void s1，const void s2，int n);
//比较参数s1指定的内存区域和参数s2指定的内存区域的前n个字节内容，如果相同则返回0，否则返回非0。
</code></pre>
<p>以mem开头的函数有：</p>
<pre><code class="language-c">#include &lt;strings.h&gt;
void memset(void s，int c，size_t n);
//将参数s指定的内存区域的前n个字节设置为参数c的内容。
void memcpy(void dest，const void src，size_t n);
//功能同bcopy，区别：函数bcopy能处理参数src和参数dest所指定的区域有重叠的情况，memcpy则不能。
int memcmp(const void s1，const void s2，size_t n);
//比较参数s1和参数s2指定区域的前n个字节内容，如果相同则返回0，否则返回非0。
</code></pre>
<h1 id="例子"><a class="header" href="#例子">例子</a></h1>
<h2 id="服务端"><a class="header" href="#服务端">服务端</a></h2>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#define DEFAULT_PORT (8000)
#define MAXLINE (4096)
int main(int argc, char** argv){
    int socket_fd, connect_fd;
    struct sockaddr_in servaddr;
    char buff[MAXLINE];
    int n;
    //初始化Socket
    if( (socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ){
        printf(&quot;create socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
        exit(0);
    }
    //初始化
    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //IP地址设置成INADDR_ANY,让系统自动获取本机的IP地址。
    servaddr.sin_port = htons(DEFAULT_PORT);      //设置的端口为DEFAULT_PORT
    //将本地地址绑定到所创建的套接字上
    if( bind(socket_fd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) == -1){
        printf(&quot;bind socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
        exit(0);
    }
    //开始监听是否有客户端连接
    if( listen(socket_fd, 10) == -1){
        printf(&quot;listen socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
        exit(0);
    }
    printf(&quot;======waiting for client's request======\n&quot;);
    while(1){
        //阻塞直到有客户端连接，不然多浪费CPU资源。
        if( (connect_fd = accept(socket_fd, (struct sockaddr*)NULL, NULL)) == -1){
            printf(&quot;accept socket error: %s(errno: %d)&quot;,strerror(errno),errno);
            continue;
        }
        //接受客户端传过来的数据
        n = recv(connect_fd, buff, MAXLINE, 0);
        //向客户端发送回应数据
        if(!fork()){
            if(send(connect_fd, &quot;Hello,you are connected!\n&quot;, 26,0) == -1)
                perror(&quot;send error&quot;);
            close(connect_fd);
            exit(0);
        }
        buff[n] = '\0';
        printf(&quot;recv msg from client: %s\n&quot;, buff);
        close(connect_fd);
    }
    close(socket_fd);
}
</code></pre>
<h2 id="客户端"><a class="header" href="#客户端">客户端</a></h2>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;

#define MAXLINE (4096)

int main(int argc, char** argv)
{
    int sockfd, n,rec_len;
    char recvline[MAXLINE], sendline[MAXLINE];
    char buf[MAXLINE];
    struct sockaddr_in servaddr;

    if( argc != 2){
        printf(&quot;usage: ./client &lt;ipaddress&gt;\n&quot;);
        exit(0);
    }

    if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0){
        printf(&quot;create socket error: %s(errno: %d)\n&quot;, strerror(errno),errno);
        exit(0);
    }

    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(8000);
    if( inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0){ //inet_pton是Linux下IP地址转换函数，将IP地址在“点分十进制”和“整数”之间转换
        printf(&quot;inet_pton error for %s\n&quot;,argv[1]);
        exit(0);
    }

    if( connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0){
        printf(&quot;connect error: %s(errno: %d)\n&quot;,strerror(errno),errno);
        exit(0);
    }

    printf(&quot;send msg to server: \n&quot;);
    fgets(sendline, 4096, stdin);
    if( send(sockfd, sendline, strlen(sendline), 0) &lt; 0)  {
        printf(&quot;send msg error: %s(errno: %d)\n&quot;, strerror(errno), errno);
        exit(0);
    }
    if((rec_len = recv(sockfd, buf, MAXLINE,0)) == -1) {
       perror(&quot;recv error&quot;);
       exit(1);
    }
    buf[rec_len]  = '\0';
    printf(&quot;Received : %s &quot;,buf);
    close(sockfd);
    exit(0);
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../计算机网络/about-net.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../计算机网络/wireshark.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../计算机网络/about-net.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../计算机网络/wireshark.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="../mermaid.min.js"></script>
                <script type="text/javascript" src="../mermaid-init.js"></script>
        
        
    </body>
</html>
